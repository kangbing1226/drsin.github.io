银联前置系统
===
---
layout: post
title:  "银联前置"
date:   2017-06-08 
category: 银联业务
tags: 银联业务
excerpt: 银联

---
* content
{:toc}

系统概述:
---
  >**银行卡前置系统**(TOPFe)是针对中国银联接口规范2.0而整合的银行卡交易处理系统，整个系统分为5个子系统：银联前置系统（NCUP）、ATM前置系统（ATMP）、POS前置系统（POSP）、加密处理系统（HSM）、批处理系统（BATCH）。
  >介于中国银联处理系统和银行帐务主机处理系统之间的一个交易处理系统，它完成跨行交易（包括本代他，他代本）的处理和转接的功能。若与其他两个子系统（ATM前置系统、POSP前置系统）整合使用，银联前置系统还可以提供本行卡交易（本代本）处理模块。
>ATM前置系统：ATM机具的接入，管理和监控ATM设备，转发ATM上进行的交易。
>**POS前置系统**：POS机具的接入，管理POS设备信息，转发POS上进行的交易。
>**加密处理系统**（HSM）：向外界提供统一的加密调用接口，支持DES软加密功能（OS：32位）；支持30所和56所加密机的接入功能。
>**批处理系统**：提供最基本的操作函数（文件入库、数据提取、报表输出等）；提供系统数据备份功能。

系统架构
---
![Alt text](./1496995188924.png)

> 他带本交易流程：      请求：通讯模块->I.1->I.2->I.3->I.4->通讯模块
> 应答：通讯模块->O.1->O.2->O.3->O.4->通讯模块 本代他交易流程：
>           请求：通讯模块->O.1->O.2->O.3->O.4->通讯模块
> 		  应答：通讯模块->I.1->I.2->I.3->I.4->通讯模块

##系统模块


- 守护进程模块  Daemon
- 桥接路由模块  Bridge
- 通讯服务模块  
>Commcup1  （南京银联通讯进程）
>Commcup2  （总行银联通讯进程）
>Commcup3 （杭州银联通讯进程）
>Commcup4  （成都银联通讯进程）
>CommDeb  （信用卡模块通讯进程）
>CoEsbCli    （核心通讯进程）
>CommAtmp （ATMP通讯进程）
>CommPosP  （POSP通讯进程）
>CoEsbSrv    （中间业务平台通讯进程）
>Commcon	  （控制台通讯进程）

- 加密机模块：  HSM         （加密模块）
>加密模块与加密机的连接与一般通讯程序的方法类似，只不过所连的是加密机而不是中心而已。本加密程序支持软加密，硬加密TCP以及硬加密串口等多种加密方式。


###Brigdge模块

- 初始化（BrigdgeInit)
守护进程Daemon fork子进程并调用系统函数execvp()替换进程上下文启动桥接进程Bridge,其中传入的参数分别为服务ID和服务序列号。之后通过srvId从数据库加载服务的配置信息到内存中。
对应调用代码如下：
```
	nReturnCode = DbsSRVINF(DBS_SELECT, &tTblSrvInf);
	nReturnCode = MsqInit (gsSrvId, gatSrvMsq);
	nReturnCode = CvtInit (gatConvType, gatUsageTransRule);
	nReturnCode = BufChgLoad(1,&tBufChgRule);
	nReturnCode = IpcDftLoad(1,&tIpcDftRule);
	nReturnCode = DbsRouteInfLoad (&gnRouteInfNum, gatRouteInf);
	nReturnCode = DbsCardBinload (&gnCardBinNum, gatCardBin);
```
其中加载服务和消息队列是调用嵌入式数据库开发语言*.pc 

> 提供对于嵌入式SQL的支持，需要数据库厂商除了提供DBMS之外，还必须提供一些工具。为了实现对于嵌入式SQL的支持，技术上必须解决以下4个问题[1]：
> 宿主语言的编译器不可能识别和接受SQL文，需要解决如何将SQL的宿主语言源代码编译成可执行码。
> 宿主语言的应用程序如何与DBMS之间传递数据和消息。 如何把对数据的查询结果逐次赋值给宿主语言程序中的变量以供其处理。
> 数据库的数据类型与宿主语言的数据类型有时不完全对应或等价，如何解决必要的数据类型转换问题。
> 嵌入式工作原理
> ![Alt text](./1497002360274.png)


流程图
```flow
st=>start: 启动Bridge
conDB=>operation: 连接数据库
loadSrv=>operation: 服务属性
loadMsq=>operation: 消息队列
loadConv=>operation: 转换规则
loadIpc=>operation: 内部结构体
loadRoute=>operation: 路由
sub=>subroutine: 加载配置信息
condb=>condition: 连接成功
Suc1=>condition: true
Suc2=>condition: true
Suc3=>condition: true
Suc4=>condition: true
Suc5=>condition: true
io=>inputoutput: 加载配置信息
e=>end: 结束

st->conDB->condb
condb(yes)->loadSrv->Suc1
Suc1(yes)->loadMsq->Suc2
Suc2(yes)->loadConv->Suc3
Suc3(yes)->loadIpc->Suc4
Suc4(yes)->loadRoute->e
Suc1(no)->e
Suc2(no)->e
Suc3(no)->e
Suc4(no)->e
condb(no)->conDB
```
- 格式转换规则是系统比较复杂的内容：
```flow
st=>start: begin
loadConv=>operation: load tbl_conv_type
condb=>condition: true
i1=>operation: j=0
i2=>operation: j++
i3=>operation: usage_key=-1
con1=>condition: j<14
forv1=>operation: 判断是否为8583转换规则
forfld=>operation: nMLoadFldInf
formsg=>operation: nMLoadMsgInf
forconv=>operation: nMLoadConInf
forbmp=>operation: nMLoadBmpInf
foripc=>operation: nMLoadIpcInf

convInit=>inputoutput: ConvInit(FldInfKey,MsgInfKey,ConInfKey,BmpInfKey,IpcInfKey)

ed=>end: end
st->loadConv->condb
condb(yes,right)->i1->i3->con1
con1(yes,right)->i2(right)->i3
con1(no)->forv1->convInit
convInit->forfld->formsg->forconv->forbmp->foripc(left)->ed
condb(no)->ed
```
为了清晰了解转换过程我们先从交易报文说起，对于发至birdge桥接模块，他需要外部的报文转换为内部结构体IPC(此IPC并非是unix系统间通讯机制)而是针对报文所存在的属性设置的结构体，比如交易中设计的主账号，交易金额，发卡机构识别码，受理机构识别码等都是内部结构的字段。那如何提取报文到内部结构体呢。对于银联前置系统的设计是将所有交易涉及到的信息都包括在结构体IPC中。有值即给对应字段赋值，没有则赋值为空，系统中用标记指示位来识别(Y/N)
- 加载域属性(nMLoadFldInf)
>8583每个域包括可比拟为两个对象域值和域长度
>比如F02主账号3136363232343234323030303030303231(ans)=>
166224242000000021
前两位16代表域值长度后面的域值，相对于主账号为变长域，但是有些域为定长比如交易处理码为6位定长字符，那如何区分是定长的域还是不定长的域呢。其实这对我们交易报文中不知晓是否为定长报文域，对我们提取报文域值没有影响，只要知道域的长度按长取值就可以了。但是如何截取呢，没有对应的尺码该如何裁剪缝衣。考虑到此报文只涉及到的是交易类报文主要包括余额查询，取款，转账等。不同的交易他们所需的报文是各银行和银联约定俗成的。他们也用最小位图和最大位图来描述那些域是所需，那些不需要出现。位图
对于某些域中存在
>



