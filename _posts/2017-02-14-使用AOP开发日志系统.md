---
layout: post
title:  "使用AOP开发管理日志系统"
date:  2017-02-14 16:19:09
categories:  架构设计与开源技术
tags:  Spring-Boot AOP
excerpt: 在Spring-Boot中使用AOP开发的一套完整的用户操作日志系统
---

* content
{:toc}

## 简要

*   分享一下昨天做的一套基于Spring AOP特性的一套日志管理系统。

## 概念

*   先来脑补一下AOP的相关知识

>   AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。

>   AOP技术恰恰相反，它利用一种称为"横切"的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为"Aspect"，即切面。所谓"切面"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。

>   使用"横切"技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。

*   Spring对AOP的支持

>   Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为：

>   1、默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了

>   2、当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理，也可强制使用CGLIB

## 开发

*  先预览一下效果图
    
    ![Object](http://jiaohongwei.github.io/images/2017-02/20170214161453.png)

1.  需要先在数据库（Oracle）创建好一个LOGGER表，用来存储日志信息，表结构如下：

    ![Object](http://jiaohongwei.github.io/images/2017-02/20170214163248.png)

2.  自定义注解 拦截方法
    
    ``` java
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ElementType.METHOD})
    @Documented
    public @interface SystemServiceLog {
        //模块名
        String moduleName() default "";
        //操作类型
        OperationType operation_type() default OperationType.SELECT;
        //操作内容
        String operation() default "";
    }

    ```

3.  定义用于记录日志的实体类

    ```java
       @Data
       @lombok.Setter
       @lombok.Getter
       @NoArgsConstructor
       @AllArgsConstructor
       @Entity
       @Table(name = "LOGGER")
       public class AspectEntity implements Serializable {
           private static final long serialVersionUID = 1L;
           @Id
           @GeneratedValue(generator = "uuid")
           @GenericGenerator(name = "uuid", strategy = "uuid")
           private String id;
           private String ip;
           private String username;
           @Column(name = "METHOD_NAME")
           private String methodname;
           private String modul;
           @Enumerated(EnumType.STRING)
           @Column(name = "OPERATION_TYPE")
           private OperationType operationtype;
           private String operation;
           private String arguments;
           private String browser;
           @Column(name = "CREATE_TIME")
           private long createtime;
       }
    ```

4.  引入AOP支持

*   导入pom文件。

    ```xml
    <!--AOP统一处理操作日志-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>

    ```

*   修改配置文件

    ```
    <!-- 启动对@AspectJ注解的支持（spring-boot 好像是默认开启的） -->  
    spring.aop.auto=true
    
    <!--通知spring使用cglib而不是jdk的来生成代理方法 AOP可以拦截到Controller->  
    spring.aop.proxy-target-class=false
    
    ```


5.  定义日志AOP切面类
    
    ```java
    import com.vg.security.UserSecurity;
    import com.vg.service.LogService;
    import com.vg.utils.UUIDUtil;
    
    import org.aspectj.lang.JoinPoint;
    import org.aspectj.lang.annotation.Aspect;
    import org.aspectj.lang.annotation.Before;
    import org.aspectj.lang.annotation.Pointcut;
    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    import org.springframework.stereotype.Component;
    import org.springframework.web.context.request.RequestContextHolder;
    import org.springframework.web.context.request.ServletRequestAttributes;
    
    import java.lang.reflect.Method;
    
    import javax.annotation.Resource;
    import javax.servlet.http.HttpServletRequest;
    
    /**
     * Created by jiaohongwei on 2017/2/13.
     */
    @Aspect
    @Component
    public class SystemLogAspect {
        private static Logger logger = LoggerFactory.getLogger(SystemLogAspect.class);
        //注入Service用于把日志保存数据库
        @Resource
        private LogService logService;
    
        //Service层切点
        @Pointcut("@annotation(com.vg.aop.SystemServiceLog)")
        public void serviceAspect() {
        }
    
        /**AspectJ支持5种类型的通知注解：
          
          -@Before 前置通知，在目标方法执行之前执行
          -@After：后置通知：在目标方法执行之后执行，无论是否发生异常
          -@AfterReturning:返回通知，在目标方法返回结果之后执行
          -@AfterThrowing：异常通知，在目标方法抛出异常之后通知。
          -@Around 环绕通知，围绕着目标方法执行。
      
        这里就不再一一介绍，我们只采用前置通知即可。
        */
    
        @Before("serviceAspect()")
        public void doBefore(JoinPoint joinPoint) {
            try {
                logService.saveOperation(getMthodRemark(joinPoint));
            } catch (Exception e) {
                //记录本地异常日志
                logger.error("异常信息:{}", e.getMessage());
            }
        }
        
        /**
         * 获取注解中对方法的描述信息 用于service层注解
         *
         * @param joinPoint 切点
         * @return 方法描述
         */
        public static AspectEntity getMthodRemark(JoinPoint joinPoint)
    
                throws Exception {
            HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
    
            AspectEntity aspectEntity = new AspectEntity();
            aspectEntity.setId(UUIDUtil.creatUUID());
            aspectEntity.setUsername(UserSecurity.getCurrentUsername());//登陆用户名
            aspectEntity.setIp(getIpAddress(request));//ip地址
            aspectEntity.setBrowser(request.getHeader("User-Agent"));//浏览器
            aspectEntity.setCreatetime(System.currentTimeMillis());//当前时间戳
            String targetName = joinPoint.getTarget().getClass().getName();
            String methodName = joinPoint.getSignature().getName();
            Object[] arguments = joinPoint.getArgs();   //获得参数列表
            StringBuffer parameters = new StringBuffer();
            for (int i = 0; i < arguments.length; i++) {
                parameters.append((i + 1) + ":" + (arguments[i]) + " ");
            }
            aspectEntity.setMethodname(methodName);//方法名
            aspectEntity.setArguments(parameters == null ? "" : String.valueOf(parameters));//参数列表
            Class targetClass = Class.forName(targetName);
            Method[] methods = targetClass.getMethods();
    
            for (Method method : methods) {
                if (method.getName().equals(methodName)) {
                    Class[] clazzs = method.getParameterTypes();
                    if (clazzs.length == arguments.length) {
                        SystemServiceLog methodCache = method.getAnnotation(SystemServiceLog.class);
                        aspectEntity.setOperation(methodCache.operation());//从注解上获取的操作内容
                        aspectEntity.setOperationtype(methodCache.operation_type());//操作类型
                        aspectEntity.setModul(methodCache.moduleName());//模块名
                        break;
                    }
                }
            }
            return aspectEntity;
        }
    
        public static String getIpAddress(HttpServletRequest request) {
            String ip = request.getHeader("x-forwarded-for");
            if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
                ip = request.getHeader("Proxy-Client-IP");
            }
            if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
                ip = request.getHeader("WL-Proxy-Client-IP");
            }
            if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
                ip = request.getHeader("HTTP_CLIENT_IP");
            }
            if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
                ip = request.getHeader("HTTP_X_FORWARDED_FOR");
            }
            if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
                ip = request.getRemoteAddr();
            }
            return ip.equals("0:0:0:0:0:0:0:1") ? "127.0.0.1" : ip;
        }
    }
    ```

6.  service层调用

    ```java
        @Override
        @SystemServiceLog(operation_type = OperationType.SELECT, operation = "查询所有的考试场次")
        public List<TCYYBResponse> getAllYycc(String username) {
            String pcdm = tcpcbRepository.findPcdmBySfkqyy(true);
            List<TCYYB> list = tcyybRepository.findByPcdm(pcdm);
            return getyyccResponse(username, list);
        } 
    ```

7.  前端

*   前端使用BootStrp-Table来展示日志信息，关于BootStrp-Table的学习可以参考我之前的 [文章](http://jiaohongwei.github.io/2016/12/22/Bootstrap-table%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/)


8.  资料

    [Spring AOP](https://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html)
