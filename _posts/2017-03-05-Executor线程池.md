---
layout: post
title:  "Executor线程池"
date:  2017-03-05 19:54:37
categories:  后端  
tags:  多线程
excerpt: 使用Executor创建线程池
---

* content
{:toc}

## 线程池概念

*   线程池的作用:

>   线程池的作用就是限制系统中执行的线程池的数量。

>   根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果。

>   少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排队等候。

>   一个任务执行完毕，再从队列的中取最前面的任务开始执行。

>   若队列中没有等待进程，线程池的这一资源处于等待。

>   当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。

*   为什么要用线程池:

>  减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。

>  可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。




##   常用线程池

1.  newSingleThreadExecutor()

>   创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。

```java

    ExecutorService executor=Executors.newSingleThreadExecutor();

```

2.  newFixedThreadPool()
        
>   创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。

```java

    ExecutorService executor=Executors.newFixedThreadPool(20);

```
    
3.  newCachedThreadPool()

   
>   创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。

```java

    ExecutorService executor=Executors.newCachedThreadPool();

```
    
4.  newScheduledThreadPool()

   
>   用于创建一个线程池，线程池中得线程能够周期性地执行给定的任务。

```java

    ExecutorService executor=Executors.newScheduledThreadPool(3);



```
    
```java

        public static void main(String[] args) {
    
    //        ExecutorService executor=Executors.newSingleThreadExecutor();
    
    //        ExecutorService executor=Executors.newFixedThreadPool(20);
    
    //            ExecutorService executor=Executors.newCachedThreadPool();
    
            ExecutorService threadPool = Executors.newScheduledThreadPool(3);
            for(int i=1;i<=10;i++){
                final int task = i;
                threadPool.execute(new Runnable() {
    
                    public void run() {
                        try {
                            Thread.sleep(500);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        for(int j=1;j<=5;j++){
                            System.out.println(Thread.currentThread().getName()+
                                    " is looping of "+j+" for task of "+task);
                        }
                    }
                });
            }
            System.out.println("all of 10 tasks has committed");
            threadPool.shutdown();
        }


```
   
